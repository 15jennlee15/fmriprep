import os
import uuid
import jinja2
from pkg_resources import resource_filename as pkgrf

import nibabel as nb
from nilearn import plotting
from nipype.interfaces import ants, fsl
from nipype.interfaces.base import File, traits
from nipype.utils import filemanip

class ReportCapableInterface(object):
    # constants
    ERROR_REPORT = 'error'
    SUCCESS_REPORT = 'success'

    def run(self):
        ''' delegates to base interface run method, then attempts to generate reports '''
        self.html_report = os.path.join(os.getcwd(), 'report.html')
        try:
            result = super(ReportCapableInterface, self).run()
            #  command line interfaces might not raise an exception, check return_code
            if result.runtime.returncode and result.runtime.returncode != 0:
                self._conditionally_generate_report(self.ERROR_REPORT)
            else:
                self._conditionally_generate_report(self.SUCCESS_REPORT)
        except:
            self._conditionally_generate_report(self.ERROR_REPORT)
            raise

    def _list_outputs(self):
        outputs = super(ReportCapableInterface, self)._list_outputs()
        if self.inputs.generate_report:
            outputs['html_report'] = self.html_report
        return outputs

    def _conditionally_generate_report(self, flag):
        ''' Do nothing if generate_report is not True.
        Otherwise delegate to a report generating method  '''

        # don't do anything unless the generate_report boolean is set to True
        if not self.inputs.generate_report:
            return

        if flag == self.SUCCESS_REPORT:
            self._generate_report()
        elif flag == self.ERROR_REPORT:
            self._generate_error_report()
        else:
            raise ValueError("Cannot generate report with flag {}. "
                             "Use constants SUCCESS_REPORT and ERROR_REPORT."
                             .format(flag))

    def _generate_report(self):
        ''' Saves an html snippet '''
        raise NotImplementedError

    def _generate_error_report(self):
        ''' Saves an html snippet '''
        # as of now we think this will be the same for every interface
        raise NotImplementedError


class RegistrationInputSpecRPT(ants.registration.RegistrationInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class RegistrationOutputSpecRPT(ants.registration.RegistrationOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class RegistrationRPT(ReportCapableInterface, ants.Registration):
    input_spec = RegistrationInputSpecRPT
    output_spec = RegistrationOutputSpecRPT

    def _generate_report(self):
        #  self.input_spec.fixed_image
        #  self.output_spec.warped_image
        with open(output_spec.html_report, 'w') as fp:
            pass

class FASTInputSpecRPT(fsl.preprocess.FASTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FASTOutputSpecRPT(fsl.preprocess.FASTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FASTRPT(ReportCapableInterface, fsl.FAST):
    input_spec = FASTInputSpecRPT
    output_spec = FASTOutputSpecRPT

    def _generate_report(self):
        raise NotImplementedError


class BETInputSpecRPT(fsl.preprocess.BETInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class BETOutputSpecRPT(fsl.preprocess.BETOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class BETRPT(ReportCapableInterface, fsl.BET):
    input_spec = BETInputSpecRPT
    output_spec = BETOutputSpecRPT

    def _overlay_file_name(self):
        ''' returns an overlay, in this order of preference: mask_file, outline_file,
        out_file, and the name of the output'''
        outputs = self.aggregate_outputs().get()

        for output_name in ['mask_file', 'outline_file', 'out_file']:
            if output_name:
                return outputs[output_name], output_name
        return None, None

    def _pick_output_file(self):
        for _, file_name in self.aggregate_outputs().get().items():
            if file_name and file_name.find('.nii') != -1: # rough check for nifti format
                return file_name
        raise Warning('Could not find outputs for BET; cannot generate report. Inputs are {} and'
                      ' outputs are {}.'.format(self.inputs, self.aggregate_outputs()))

    def _generate_report(self):
        ''' generates a report showing three orthogonal slices of an arbitrary
        volume of in_file, with the resulting binary brain mask overlaid '''

        overlay_file_name, overlay_label = self._overlay_file_name()
        if overlay_file_name:
            generate_overlay_3d_report(self.inputs.in_file, overlay_file_name, self.html_report,
                                       "BET: " + overlay_label + " over the input (anatomical)",
                                       self.inputs, self.aggregate_outputs())
        else: # just print an output (no overlay)
            file_name = self._pick_output_file()
            generate_3d_report(file_name, self.html_report, "BET: " + file_name, self.inputs,
                               self.aggregate_outputs())

    def _generate_error_report(self):
        pass

class FLIRTInputSpecRPT(fsl.preprocess.FLIRTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FLIRTOutputSpecRPT(fsl.preprocess.FLIRTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FLIRTRPT(ReportCapableInterface, fsl.FLIRT):
    input_spec = FLIRTInputSpecRPT
    output_spec = FLIRTOutputSpecRPT

    def _generate_report(self):
        ref = self.input_spec.reference
        ref_image_name = '{}.svg'.format(ref)
        out = self.output_spec.out_file
        out_image_name = '{}.svg'.format(out)

        plotting.plot_img(ref, output_file=ref_image_name)
        plotting.plot_img(out, output_file=out_image_name)
        
        with open(ref_image_name, 'r') as ref_fp:
            reference_image = ref_fp.readlines()
        with open(output_image_name, 'r') as out_fp:
            output_image = out_fp.readlines()

        searchpath = pkgrf('fmriprep', '/')
        env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(searchpath=searchpath),
            trim_blocks=True, lstrip_blocks=True
        )
        report_tpl = env.get_template('viz/flirt_report.tpl')
        report_render = report_tpl.render(
            reference_image_image=reference_imagem,
            output_image=output_image
        )

        with open(os.path.join(self.out_dir, self.out_filename), 'w') as fp:
            fp.write(report_render)
        return report_render

def svg_file_name(filename):
    ''' strips the extension from the string (assuming it's a file name), if it
    exists, and uses .svg instead '''
    path, base_name, ext = filemanip.split_filename(filename)
    return base_name + '.svg'

def save_html(template, report_file_name, unique_string, **kwargs):
    ''' save an actual html file with name report_file_name. unique_string is
    used to uniquely identify the html/css/js/etc generated for this report '''

    searchpath = pkgrf('fmriprep', '/')
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(searchpath=searchpath),
        trim_blocks=True, lstrip_blocks=True
    )
    report_tpl = env.get_template('viz/' + template)
    kwargs['unique_string'] = unique_string
    report_render = report_tpl.render(kwargs)

    with open(report_file_name, 'w') as handle:
        handle.write(report_render)

def prepare_3d_svg(nifti_file, **kwargs):
    ''' If nifti_file is 4d, use the first volume.
    returns svg file name '''
    svg_file = svg_file_name(nifti_file)

    plotting.plot_img(nifti_file, output_file=svg_file, **kwargs)

    with open(svg_file, 'r') as file_obj:
        image_svg = file_obj.readlines()
    image_svg = image_svg[4:] # strip out extra DOCTYPE, etc headers
    image_svg = ''.join(image_svg) # straight up giant string

    return image_svg

def generate_overlay_3d_report(base_file_name, overlay_file_name, report_file_name, title, inputs, outputs):
    ''' generates a report showing three orthogonal slices of an arbitrary
    volume of base_file_name, with overlay_file_name overlaid '''
    cut_coords = plotting.find_xyz_cut_coords(overlay_file_name)

    base_image = prepare_3d_svg(base_file_name, cut_coords=cut_coords, cmap="gray")
    overlay_image = prepare_3d_svg(overlay_file_name, cut_coords=cut_coords)

    save_html(template='overlay_3d_report.tpl', report_file_name=report_file_name,
              unique_string='bet' + str(uuid.uuid4()), base_image=base_image,
              overlay_image=overlay_image, title=title, inputs=inputs, outputs=outputs)

def generate_3d_report(file_name, report_file_name, title, inputs, outputs):
    ''' generates a basic 3d report given an image '''
    image = prepare_3d_svg(file_name)

    save_html(template='overlay_3d_report.tpl', report_file_name=report_file_name,
              unique_string=uuid.uuid4(), base_image=image, title=title, inputs=inputs,
              outputs=outputs)

import os
import uuid
import jinja2
from pkg_resources import resource_filename as pkgrf

import nibabel as nb
from nilearn.plotting import plot_img
from nipype.interfaces import ants, fsl
from nipype.interfaces.base import File, traits


class ReportCapableInterface(object):
    # constants
    ERROR_REPORT = 'error'
    SUCCESS_REPORT = 'success'

    def run(self, **inputs):
        ''' delegates to base interface run method, then attempts to generate reports '''
        try:
            result = super(self, ReportCapableInterface).run()
            #  command line interfaces might not raise an exception, check return_code
            if result.runtime.return_code != None and result.runtime.return_code != 0:
                self._conditionally_generate_report(self.ERROR_REPORT)
            else:
                self._conditionally_generate_report(self.SUCCESS_REPORT)
        except:
            self._conditionally_generate_report(self.ERROR_REPORT)
            raise

    def _conditionally_generate_report(self, flag):
        ''' Do nothing if generate_report is not True.
        Otherwise delegate to a report generating method  '''
        # don't do anything unless the generate_report boolean is set to True
        if self.inputs.generate_report != None or not self.inputs.generate_report:
            return

        if flag == self.SUCCESS_REPORT:
            self._generate_report()
        elif flag == self.ERROR_REPORT:
            self._generate_error_report()
        else:
            raise ValueError("Cannot generate report with flag {}. "
                             "Use constants SUCCESS_REPORT and ERROR_REPORT."
                             .format(flag))

    def _generate_report(self):
        ''' Saves an html snippet '''
        raise NotImplementedError

    def _generate_error_report(self):
        ''' Saves an html snippet '''
        # as of now we think this will be the same for every interface
        raise NotImplementedError



class RegistrationInputSpecRPT(ants.registration.RegistrationInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class RegistrationOutputSpecRPT(ants.registration.RegistrationOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class RegistrationRPT(ReportCapableInterface, ants.Registration):
    input_spec = RegistrationInputSpecRPT
    output_spec = RegistrationOutputSpecRPT

    def _generate_report(self):
        #  self.input_spec.fixed_image
        #  self.output_spec.warped_image
        with open(output_spec.html_report, 'w') as fp:
            pass

class FASTInputSpecRPT(fsl.preprocess.FASTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FASTOutputSpecRPT(fsl.preprocess.FASTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FASTRPT(ReportCapableInterface, fsl.FAST):
    input_spec = FASTInputSpecRPT
    output_spec = FASTOutputSpecRPT

    def _generate_report(self):
        raise NotImplementedError


class BETInputSpecRPT(fsl.preprocess.BETInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class BETOutputSpecRPT(fsl.preprocess.BETOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class BETRPT(ReportCapableInterface, fsl.BET):
    input_spec = BETInputSpecRPT
    output_spec = BETOutputSpecRPT

    def _overlay_file_name(self):
        ''' returns an overlay, in this order of preference: mask_file, outline_file,
        out_file '''
        file_name = self.outputs.mask_file or self.outputs.outline_file or self.outputs.out_file
        if not file_name:
            raise ValueError()

    def _prepare_3d_svg(self, filename):
        ''' filename contains a nifti. If it's 4d, use the first volume.
        returns tuple (image data as svg, image file name)'''
        image = nb.load(self.inputs.in_file).get_data()[:, :, :, 0] ###
        image_file = svg_file_name(filename)

        plot_img(image, output_file=image_file)

        with open(image_file, 'r') as file_obj:
            image_svg = file_obj.readlines()

        return image_svg

    def _generate_overlay_3d_report(self, base_file_name, overlay_file_name):
        ''' generates a report showing three orthogonal slices of an arbitrary
        volume of base_file_name, with overlay_file_name overlaid '''
        base_image = self._prepare_3d_svg(base_file_name)
        overlay_image = self._prepare_3d_svg(overlay_file_name)

        searchpath = pkgrf('fmriprep', '/')
        env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(searchpath=searchpath),
            trim_blocks=True, lstrip_blocks=True
        )
        report_tpl = env.get_template('viz/overlay_3d_report.tpl')
        report_render = report_tpl.render(
            unique_string=uuid.uuid4(),
            base_image_image=base_image,
            overlay_image=overlay_image
        )

        with open(os.path.join(self.out_dir, self.out_filename), 'w') as handle:
            handle.write(report_render)

    def _generate_report(self):
        ''' generates a report showing three orthogonal slices of an arbitrary
        volume of in_file, with the resulting binary brain mask overlaid '''
        self._generate_overlay_3d_report(self.inputs.in_file, self._overlay_file_name())


class FLIRTInputSpecRPT(fsl.preprocess.FLIRTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FLIRTOutputSpecRPT(fsl.preprocess.FLIRTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FLIRTRPT(ReportCapableInterface, fsl.FLIRT):
    input_spec = FLIRTInputSpecRPT
    output_spec = FLIRTOutputSpecRPT

    def _generate_report(self):
        ref = self.input_spec.reference
        ref_image_name = '{}.svg'.format(ref)
        out = self.output_spec.out_file
        out_image_name = '{}.svg'.format(out)

        plot_img(ref, output_file=ref_image_name)
        plot_img(out, output_file=out_image_name)
        
        with open(ref_image_name, 'r') as ref_fp:
            reference_image = ref_fp.readlines()
        with open(output_image_name, 'r') as out_fp:
            output_image = out_fp.readlines()

        searchpath = pkgrf('fmriprep', '/')
        env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(searchpath=searchpath),
            trim_blocks=True, lstrip_blocks=True
        )
        report_tpl = env.get_template('viz/flirt_report.tpl')
        report_render = report_tpl.render(
            reference_image_image=reference_imagem,
            output_image=output_image
        )

        with open(os.path.join(self.out_dir, self.out_filename), 'w') as fp:
            fp.write(report_render)
        return report_render

def svg_file_name(filename):
    ''' strips the extension from the string (assuming it's a file name), if it
    exists, and uses .svg instead '''
    return os.path.splitext(filename)[0] + '.svg'
